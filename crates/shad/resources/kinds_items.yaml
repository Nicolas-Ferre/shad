max_u32: &max_u32 4294967295
import_index_key: &import_index_key '@import'
no_return_type_name: &no_return_type_name '<no return>'

duplicated_item_check: &duplicated_item_check
  assertion: |-
    for other_node in root.children() {
      if other_node.id() < node.id() && other_node.key() == node.key() {
        return false;
      }
    }
    true
  error:
    node: 'node'
    title: '`${node.key()} defined multiple times`'
    label: '"duplicated item"'
    info:
      - node: |-
          for other_node in root.children() {
            if other_node.key() == node.key() {
              return other_node;
            }
          }
        title: '"same item defined here"'

kinds:
  import_item:
    sequence: [ import_kw, import_path_prefix, ident, semicolon ]
    sequence_error_after: import_kw
    index_key:
      - string: *import_index_key
    import_path:
      parent: tilde
      segment: ident
    validation:
      - assertion: 'node.import_path().exists()'
        error:
          node: 'node'
          title: '"imported file not found"'
          label: '`no file found at ``${node.import_path().to_str()}```'

  import_path_prefix:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ import_path_segment, dot ]
    sequence_error_after: dot

  import_path_segment:
    choice: [ tilde, ident ]

  buffer_item:
    sequence: [ buf_kw, ident, eq, typed_expr, semicolon ]
    sequence_error_after: buf_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    buffer:
      ident: ident
    validation:
      - *duplicated_item_check
    transpilation: |-
      `@group(0) @binding(${next_binding()})
      var<storage, read_write> _${node.id()}: ${node.child("typed_expr").req().type().req().transpile_type()};`
    init_shader:
      transpilation: |-
        let dependencies = "";
        for source in node.nested_sources() {
          if source.kind() == "buffer_item" || source.kind() == "fn_item" {
            dependencies += source.transpile() + "\n";
          }
        }
        `${dependencies}
        ${node.transpile()}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
            _${node.id()} = ${node.child("typed_expr").req().transpile()};
        }`

  init_item:
    sequence: [ init_kw, block ]
    sequence_error_after: init_kw
    init_shader:
      transpilation: |-
        let dependencies = "";
        for source in node.nested_sources() {
          if source.kind() == "buffer_item" || source.kind() == "fn_item" {
            dependencies += source.transpile() + "\n";
          }
        }
        `${dependencies}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
        ${node.child("block").req().transpile()}
        }`

  run_item:
    sequence: [ run_kw, block ]
    sequence_error_after: run_kw
    run_shader:
      transpilation: |-
        let dependencies = "";
        for source in node.nested_sources() {
          if source.kind() == "buffer_item" || source.kind() == "fn_item" {
            dependencies += source.transpile() + "\n";
          }
        }
        `${dependencies}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
        ${node.child("block").req().transpile()}
        }`

  fn_item:
    sequence: [ fn_kw, ident, open_parenthesis, fn_param_group, close_parenthesis, fn_return_type, block ]
    sequence_error_after: fn_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '('
      - nested: param_type
        separator: ', '
      - string: ')` function'
    validation:
      - *duplicated_item_check
      - assertion: |-
          let last_stmt = node.child("block").req().child("stmts").req().last_child();
          let has_return_stmt = last_stmt.is_some() && last_stmt.req().kind() == "return_stmt";
          let has_return_type = node.child("fn_return_type").req().children().len() > 0;
          has_return_stmt || !has_return_type
        error:
          node: 'node.child("block").req().child("stmts").req().last_child().or(node.child("block")).req()'
          title: '"missing return statement"'
          label: '"last statement should be a `return` statement"'
          info:
            - node: 'node.child("fn_return_type").req()'
              title: '"the function has a return type"'
      - assertion: |-
          let expected_type = node.child("fn_return_type").req().type().req();
          let returned_type = node.child("block").req().child("stmts").req().last_child().req().type().req();
          returned_type == "<no return>" || expected_type == "<no return>" || returned_type == expected_type
        error:
          node: 'node.child("block").req().child("stmts").req().last_child().req()'
          title: '"invalid returned type"'
          label: '`returned type is ``${node.child("block").req().child("stmts").req().last_child().req().type().req()}```'
          info:
            - node: 'node.child("fn_return_type").req()'
              title: '`expected type is ``${node.child("fn_return_type").req().type().req()}```'
    transpilation: |-
      let param_vars = "";
      for group in node.child("fn_param_group").req().children() {
        let first_param_id = group.child("fn_param").req().id();
        param_vars += `var _${first_param_id} = _p${first_param_id}; `;
        for other_param in group.child("fn_other_params").req().children() {
          let other_param_id = other_param.child("fn_param").req().id();
          param_vars += `var _${other_param_id} = _p${other_param_id}; `;
        } 
      }
      `fn _${node.id()}(${node.child("fn_param_group").req().transpile()}) ${node.child("fn_return_type").req().transpile()} {
      ${param_vars}
      ${node.child("block").req().transpile()}
      }`

  fn_return_type:
    min_repeat: 0
    max_repeat: 1
    sequence: [ arrow, type ]
    sequence_error_after: arrow
    transpilation: '"-> " + node.child("type").req().transpile()'
    type_resolution:
      default_name: *no_return_type_name

  fn_param_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ fn_param, fn_other_params, fn_params_final_comma ]
    sequence_error_after: fn_param
    transpilation: 'node.child("fn_param").req().transpile() + node.child("fn_other_params").req().transpile()'

  fn_other_params:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, fn_param ]
    sequence_error_after: fn_param
    transpilation: '", " + node.child("fn_param").req().transpile()'

  fn_params_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  fn_param:
    sequence: [ ident, colon, param_type ]
    sequence_error_after: ident
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    transpilation: '`_p${node.id()}: ${node.child("param_type").req().transpile()}`'

  param_type:
    sequence: [ type ]
    sequence_error_after: type
    transpilation: 'node.child("type").req().transpile()'

  type:
    sequence: [ ident ]
    sequence_error_after: ident
    transpilation: 'node.slice().transpile_type()'
    type_resolution:
      child_slice: ident

  block:
    sequence: [ open_bracket, stmts, close_bracket ]
    sequence_error_after: open_bracket
    transpilation: |-
      `{
      ${node.child("stmts").req().transpile()}
      }`
