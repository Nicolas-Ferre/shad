max_u32: &max_u32 4294967295
import_index_key: &import_index_key '@import'
no_return_type_name: &no_return_type_name '<no return>'

duplicated_item_check: &duplicated_item_check
  assertion: |-
    for other_node in root.children() {
      if other_node.id() < node.id() && other_node.key() == node.key() {
        return false;
      }
    }
    true
  error:
    node: 'node'
    title: '`${node.key()} defined multiple times`'
    label: '"duplicated item"'
    info:
      - node: |-
          for other_node in root.children() {
            if other_node.key() == node.key() {
              return other_node;
            }
          }
        title: '"same item defined here"'

kinds:
  import_item:
    sequence: [ import_kw, import_path_prefix, ident, semicolon ]
    sequence_error_after: import_kw
    index_key:
      - string: *import_index_key
    import_path:
      parent: tilde
      segment: ident
    validation:
      - assertion: 'node.import_path().exists()'
        error:
          node: 'node'
          title: '"imported file not found"'
          label: '`no file found at ``${node.import_path().to_str()}```'

  import_path_prefix:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ import_path_segment, dot ]
    sequence_error_after: dot

  import_path_segment:
    choice: [ tilde, ident ]

  buffer_item:
    sequence: [ buf_kw, ident, eq, typed_expr, semicolon ]
    sequence_error_after: buf_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    buffer:
      ident: ident
    validation:
      - *duplicated_item_check
    transpilation: |-
      @group(0) @binding({{binding}})
      var<storage, read_write> _{{self_id}}: {{expr_type:typed_expr}};
    init_shader:
      transpilation: |-
        {{nested_sources:buffer_item;fn_item}}
        {{self}}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
            _{{self_id}} = {{child:typed_expr}};
        }

  init_item:
    sequence: [ init_kw, block ]
    sequence_error_after: init_kw
    init_shader:
      transpilation: |-
        {{nested_sources:buffer_item;fn_item}}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
        {{child:block}}
        }

  run_item:
    sequence: [ run_kw, block ]
    sequence_error_after: run_kw
    run_shader:
      transpilation: |-
        {{nested_sources:buffer_item;fn_item}}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
        {{child:block}}
        }

  fn_item:
    sequence: [ fn_kw, ident, open_parenthesis, fn_param_group, close_parenthesis, fn_return_type, block ]
    sequence_error_after: fn_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '('
      - nested: param_type
        separator: ', '
      - string: ')` function'
    validation:
      - *duplicated_item_check
      - assertion: |-
          let last_stmt = node.child("block").req().child("stmts").req().last_child();
          let has_return_stmt = last_stmt.is_some() && last_stmt.req().kind() == "return_stmt";
          let has_return_type = node.child("fn_return_type").req().children().len() > 0;
          has_return_stmt || !has_return_type
        error:
          node: 'node.child("block").req().child("stmts").req().last_child().or(node.child("block")).req()'
          title: '"missing return statement"'
          label: '"last statement should be a `return` statement"'
          info:
            - node: 'node.child("fn_return_type").req()'
              title: '"the function has a return type"'
      - assertion: |-
          let expected_type = node.child("fn_return_type").req().type().req();
          let returned_type = node.child("block").req().child("stmts").req().last_child().req().type().req();
          returned_type == "<no return>" || expected_type == "<no return>" || returned_type == expected_type
        error:
          node: 'node.child("block").req().child("stmts").req().last_child().req()'
          title: '"invalid returned type"'
          label: '`returned type is ``${node.child("block").req().child("stmts").req().last_child().req().type().req()}```'
          info:
            - node: 'node.child("fn_return_type").req()'
              title: '`expected type is ``${node.child("fn_return_type").req().type().req()}```'
    transpilation: |-
      fn _{{self_id}}({{child:fn_param_group}}) {{child:fn_return_type}} {
      {{fn_param_vars:fn_param}}
      {{child:block}}
      }

  fn_return_type:
    min_repeat: 0
    max_repeat: 1
    sequence: [ arrow, type ]
    sequence_error_after: arrow
    transpilation: '-> {{child:type}}'
    type_resolution:
      default_name: *no_return_type_name

  fn_param_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ fn_param, fn_other_params, fn_params_final_comma ]
    sequence_error_after: fn_param
    transpilation: '{{child:fn_param}}{{child:fn_other_params}}'

  fn_other_params:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, fn_param ]
    sequence_error_after: fn_param
    transpilation: ', {{child:fn_param}}'

  fn_params_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  fn_param:
    sequence: [ ident, colon, param_type ]
    sequence_error_after: ident
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    transpilation: '_p{{self_id}}: {{child:param_type}}'

  param_type:
    sequence: [ type ]
    sequence_error_after: type
    transpilation: '{{child:type}}'

  type:
    sequence: [ ident ]
    sequence_error_after: ident
    transpilation: '{{slice_as_type}}'
    type_resolution:
      child_slice: ident

  block:
    sequence: [ open_bracket, stmts, close_bracket ]
    sequence_error_after: open_bracket
    transpilation: |-
      {
      {{child:stmts}}
      }
