max_u32: &max_u32 4294967295
import_index_key: &import_index_key '@import'
no_return_type_name: &no_return_type_name '<no return>'

duplicated_item_check: &duplicated_item_check
  assertion: '!root.children().map(|| this.children()[0]).some(|| this.id() < node.id() && this.key() == node.key())'
  error:
    node: 'node'
    title: '`${node.key()} defined multiple times`'
    label: '"duplicated item"'
    info:
      - node: 'root.children().map(|| this.children()[0]).find(|| this.key() == node.key())'
        title: '"same item defined here"'

recursive_item_check: &recursive_item_check
  assertion: 'let id = node.id(); !node.nested_sources().some(|| this.id() == id)'
  error:
    node: 'node'
    title: '"item definition with circular dependency"'
    label: '"this item is directly or indirectly referring to itself"'

kinds:
  import_item:
    sequence: [ import_kw, import_path_prefix, ident, semicolon ]
    sequence_error_after: import_kw
    index_key:
      - string: *import_index_key
    import_path:
      parent: tilde
      segment: ident
    validation:
      - assertion: 'node.import_path().exists()'
        error:
          node: 'node'
          title: '"imported file not found"'
          label: '`no file found at ``${node.import_path().to_str()}```'

  import_path_prefix:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ import_path_segment, dot ]
    sequence_error_after: dot

  import_path_segment:
    choice: [ tilde, ident ]

  buffer_item:
    sequence: [ buf_kw, ident, eq, typed_expr, semicolon ]
    sequence_error_after: buf_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    buffer:
      ident: ident
    validation:
      - *duplicated_item_check
      - *recursive_item_check
    transpilation: |-
      `@group(0) @binding(${next_binding()})
      var<storage, read_write> _${node.id()}: ${node.typed_expr.type().type_wgsl()};`
    buffer_init_shader:
      transpilation: |-
        `${node.nested_sources()
          .filter(|| this.kind() == "buffer_item" || this.kind() == "fn_item")
          .map(|| this.wgsl())
          .join("\n")}
        ${node.wgsl()}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
            _${node.id()} = ${node.typed_expr.wgsl()};
        }`

  init_item:
    sequence: [ init_kw, non_return_block ]
    sequence_error_after: init_kw
    init_shader:
      transpilation: |-
        `${node.nested_sources()
          .filter(|| this.kind() == "buffer_item" || this.kind() == "fn_item")
          .map(|| this.wgsl())
          .join("\n")}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
        ${node.non_return_block.wgsl()}
        }`

  run_item:
    sequence: [ run_kw, non_return_block ]
    sequence_error_after: run_kw
    run_shader:
      transpilation: |-
        `${node.nested_sources()
          .filter(|| this.kind() == "buffer_item" || this.kind() == "fn_item")
          .map(|| this.wgsl())
          .join("\n")}
        @compute
        @workgroup_size(1, 1, 1)
        fn main() {
        ${node.non_return_block.wgsl()}
        }`

  fn_item:
    sequence: [ fn_kw, ident, open_parenthesis, fn_param_group, close_parenthesis, fn_return_type, block ]
    sequence_error_after: fn_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '('
      - nested: param_type
        separator: ', '
      - string: ')` function'
    validation:
      - *duplicated_item_check
      - *recursive_item_check
      - assertion: |-
          let last_stmt = node.block.stmts.children().map(|| this.children()[0]).last();
          let has_return_stmt = last_stmt.is_some() && last_stmt.unwrap_or_stop().kind() == "return_stmt";
          let has_return_type = node.fn_return_type.children().len() > 0;
          has_return_stmt || !has_return_type
        error:
          node: 'node.block.stmts.children().map(|| this.children()[0]).last().unwrap_or(node.block)'
          title: '"missing return statement"'
          label: '"last statement should be a `return` statement"'
          info:
            - node: 'node.fn_return_type'
              title: '"the function has a return type"'
      - assertion: |-
          let expected_type = node.fn_return_type.type();
          let last_stmt = node.block.stmts.children().map(|| this.children()[0]).last().unwrap_or_stop();
          let returned_type = last_stmt.type();
          last_stmt.kind() != "return_stmt" || returned_type == "<no return>" || returned_type == expected_type
        error:
          node: 'node.block.stmts.children().map(|| this.children()[0]).last().unwrap_or_stop()'
          title: '"invalid returned type"'
          label: '`returned type is ``${node.block.stmts.children().map(|| this.children()[0]).last().unwrap_or_stop().type()}```'
          info:
            - node: 'node.fn_return_type'
              title: '`expected type is ``${node.fn_return_type.type()}```'
      - assertion: |-
          let params = node.nested_children("fn_param");
          let _params = params; // to avoid data race
          !params.some(|param, i| _params.index_of(|| this.ident.slice() == param.ident.slice()) < i)
        error:
          node: |-
            let params = node.nested_children("fn_param");
            let _params = params; // to avoid data race
            params.find(|param, i| _params.index_of(|| this.ident.slice() == param.ident.slice()) < i)
          title: '"function parameter defined multiple times"'
          label: '"duplicated parameter name"'
          info:
            - node: |-
                let params = node.nested_children("fn_param");
                let _params = params; // to avoid data race
                params.find_map(|param, i| {
                  let index = _params.index_of(|| this.ident.slice() == param.ident.slice());
                  if index < i { _params[index] } else { () }
                })
              title: '"same parameter name defined here"'
    transpilation: |-
      `fn _${node.id()}(${node.fn_param_group.wgsl()}) ${node.fn_return_type.wgsl()} {
      ${node.nested_children("fn_param").map(|| `var _${this.id()} = _p${this.id()};`).join("")}
      ${node.block.wgsl()}
      }`

  fn_return_type:
    min_repeat: 0
    max_repeat: 1
    sequence: [ arrow, type ]
    sequence_error_after: arrow
    transpilation: '"-> " + node.type.wgsl()'
    type_resolution:
      default_name: *no_return_type_name

  fn_param_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ fn_param, fn_other_params, fn_params_final_comma ]
    sequence_error_after: fn_param
    transpilation: 'node.fn_param.wgsl() + node.fn_other_params.wgsl()'

  fn_other_params:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, fn_param ]
    sequence_error_after: fn_param
    transpilation: '", " + node.fn_param.wgsl()'

  fn_params_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  fn_param:
    sequence: [ ident, colon, param_type ]
    sequence_error_after: ident
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    transpilation: '`_p${node.id()}: ${node.param_type.wgsl()}`'

  param_type:
    sequence: [ type ]
    sequence_error_after: type
    transpilation: 'node.type.wgsl()'

  type:
    sequence: [ ident ]
    sequence_error_after: ident
    transpilation: 'node.slice().type_wgsl()'
    type_resolution:
      child_slice: ident

  non_return_block:
    sequence: [ block ]
    sequence_error_after: block
    validation:
      - assertion: '!node.block.stmts.children().map(|| this.children()[0]).some(|| this.kind() == "return_stmt")'
        error:
          node: 'node.block.stmts.children().map(|| this.children()[0]).find(|| this.kind() == "return_stmt")'
          title: '"`return` statement used outside a function"'
          label: '"not allowed statement"'
    transpilation: 'node.block.wgsl()'

  block:
    sequence: [ open_bracket, stmts, close_bracket ]
    sequence_error_after: open_bracket
    validation:
      - assertion: |-
          let stmts = node.stmts.children().map(|| this.children()[0]);
          let last_index = stmts.len() - 1;
          !stmts.some(|stmt, i| stmt.kind() == "return_stmt" && i < last_index)
        error:
          node: |-
            let stmts = node.stmts.children().map(|| this.children()[0]);
            let last_index = stmts.len() - 1;
            stmts.find(|stmt, i| stmt.kind() == "return_stmt" && i < last_index)
          title: '"`return` statement before end of the block"'
          label: '"only allowed at the end of a block"'
    transpilation: |-
      `{
      ${node.stmts.wgsl()}
      }`
