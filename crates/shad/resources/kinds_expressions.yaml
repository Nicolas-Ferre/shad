max_u32: &max_u32 4294967295

missing_source_check: &missing_source_check
  assertion: 'node.has_source()'
  error:
    node: 'node'
    title: '"undefined item"'
    label: '`${node.source_key()} is undefined`'

kinds:
  typed_expr:
    sequence: [ expr ]
    sequence_error_after: expr
    validation:
      - assertion: 'node.type() != "<no return>"'
        error:
          node: 'node'
          title: '"invalid expression type"'
          label: '"this function does not return a value"'
    transpilation: 'node.expr.wgsl()'

  expr:
    choice: [ true_expr, false_expr, fn_call_expr, var_ident_expr, f32_expr, u32_expr, i32_expr ]

  var_ident_expr:
    sequence: [ ident ]
    sequence_error_after: ident
    index_key_source:
      key:
        - string: '`'
        - slice: true
        - string: '` variable'
      criteria:
        - kind: local_var_def_stmt
          can_be_after: false
        - kind: fn_param
          can_be_after: false
          allowed_siblings:
            - parent_index: 1 # `fn_item` node
              child_offset: 4 # `fn_param_group` child node
        - kind: buffer_item
          can_be_after: false
    validation:
      - *missing_source_check
    type_resolution:
      source_children: [ typed_expr, param_type ]
    transpilation: '`_${node.source().id()}`'

  fn_call_expr:
    sequence: [ ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: open_parenthesis
    index_key_source:
      key:
        - string: '`'
        - slice_child: ident
        - string: '('
        - type_nested_child: fn_arg
          separator: ', '
        - string: ')` function'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.fn_arg_group.wgsl()})`'
    type_resolution:
      source_children: [ fn_return_type ]

  fn_arg_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ fn_arg, fn_other_args, fn_args_final_comma ]
    sequence_error_after: fn_arg
    transpilation: 'node.fn_arg.wgsl() + node.fn_other_args.wgsl()'

  fn_arg:
    sequence: [ expr ]
    sequence_error_after: expr
    transpilation: 'node.expr.wgsl()'

  fn_other_args:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, fn_arg ]
    sequence_error_after: fn_arg
    transpilation: '", " + node.fn_arg.wgsl()'

  fn_args_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  f32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: '.', end: '.' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`f32` literal'
    validation:
      - assertion: 'parse_f32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `f32` literal"'
    type_resolution:
      name: f32
    transpilation: '`f32(${node.slice().replaced("_", "")})`'

  u32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: 'u', end: 'u' }
        min_length: 1
        max_length: 1
    display_name: '`u32` literal'
    validation:
      - assertion: 'parse_u32(node.slice().replaced("_", "").replaced("u", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `u32` literal"'
    type_resolution:
      name: u32
    transpilation: '`u32(${node.slice().replaced("_", "")})`'

  i32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`i32` literal'
    validation:
      - assertion: 'parse_i32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `i32` literal"'
    type_resolution:
      name: i32
    transpilation: '`i32(${node.slice().replaced("_", "")})`'

  true_expr:
    string: 'true'
    type_resolution:
      name: bool
    transpilation: '"u32(true)"'

  false_expr:
    string: 'false'
    type_resolution:
      name: bool
    transpilation: '"u32(false)"'
