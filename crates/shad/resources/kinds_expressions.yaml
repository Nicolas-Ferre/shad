max_u32: &max_u32 4294967295

missing_source_check: &missing_source_check
  assertion: |-
    node.source_key(); // to ensure the source key can be computed 
    node.has_source()
  error:
    node: 'node'
    title: '"undefined item"'
    label: '`${node.source_key()} is undefined`'

kinds:
  typed_expr:
    sequence: [ expr ]
    sequence_error_after: expr
    validation:
      - assertion: 'node.type() != "<no return>"'
        error:
          node: 'node'
          title: '"invalid expression type"'
          label: '"this function does not return a value"'
    transpilation: 'node.expr.wgsl()'

  expr:
    choice:
      - flat_binary_expr
      - associated_fn_call_expr
      - fn_call_expr
      - parenthesis_expr
      - true_expr
      - false_expr
      - var_ident_expr
      - f32_expr
      - u32_expr
      - i32_expr
      - neg_unary_expr
      - not_unary_expr
    transpilation: 'node.children()[0].wgsl()'

  simple_expr:
    choice:
      - associated_fn_call_expr
      - fn_call_expr
      - parenthesis_expr
      - true_expr
      - false_expr
      - var_ident_expr
      - f32_expr
      - u32_expr
      - i32_expr
      - neg_unary_expr
      - not_unary_expr
    transpilation: 'node.children()[0].wgsl()'

  var_ident_expr:
    sequence: [ ident ]
    sequence_error_after: ident
    index_key_source:
      key: '```${node.slice()}`` variable`'
      criteria:
        - kind: local_var_def_stmt
          can_be_after: false
        - kind: fn_param
          can_be_after: false
          allowed_siblings:
            - parent_index: 1 # `fn_item` node
              child_offset: 4 # `fn_param_group` child node
        - kind: buffer_item
          can_be_after: true
    validation:
      - *missing_source_check
    type_resolution:
      source_children: [ typed_expr, param_type ]
    transpilation: '`_${node.source().id()}`'

  fn_call_expr:
    sequence: [ ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: open_parenthesis
    index_key_source:
      key: '```${node.ident.slice()}(${node.nested_children("expr").map(|| this.type()).join(", ")})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.fn_arg_group.wgsl()})`'
    type_resolution:
      source_children: [ fn_return_type ]

  associated_fn_call_expr:
    sequence: [ simple_expr, dot, ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: dot
    index_key_source:
      key: '```${node.ident.slice()}(${([node.simple_expr] + node.nested_children("expr")).map(|| this.type()).join(", ")})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.simple_expr.wgsl()}, ${node.fn_arg_group.wgsl()})`'
    type_resolution:
      source_children: [ fn_return_type ]

  fn_arg_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ expr, fn_other_args, fn_args_final_comma ]
    sequence_error_after: expr
    transpilation: 'node.expr.wgsl() + node.fn_other_args.wgsl()'

  fn_other_args:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, expr ]
    sequence_error_after: expr
    transpilation: '", " + node.expr.wgsl()'

  fn_args_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  parenthesis_expr:
    sequence: [ open_parenthesis, expr, close_parenthesis ]
    sequence_error_after: open_parenthesis
    transpilation: '`(${node.expr.wgsl()})`'

  neg_unary_expr:
    sequence: [ hyphen, simple_expr ]
    sequence_error_after: hyphen
    index_key_source:
      key: '```__neg__(${node.simple_expr.type()})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.simple_expr.wgsl()})`'

  not_unary_expr:
    sequence: [ excl_mark, simple_expr ]
    sequence_error_after: excl_mark
    index_key_source:
      key: '```__not__(${node.simple_expr.type()})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.simple_expr.wgsl()})`'

  flat_binary_expr:
    sequence: [ simple_expr, binary_right ]
    sequence_error_after: binary_sub_right
    binary_transformation:
      new_kind: binary_expr
      operand: simple_expr
      operator: binary_operator
      operator_priority:
        - [ '||' ]
        - [ '&&' ]
        - [ '<', '>', '<=', '>=', '==', '!=' ]
        - [ '+', '-' ]
        - [ '*', '/',  '%' ]

  binary_right:
    min_repeat: 1
    max_repeat: *max_u32
    sequence: [ binary_operator, simple_expr ]
    sequence_error_after: binary_operator

  binary_operator:
    choice:
      - plus
      - hyphen
      - star
      - slash
      - percent
      - compare_le
      - compare_ge
      - compare_eq
      - compare_ne
      - open_angle_bracket
      - close_angle_bracket
      - and
      - or
    transpilation: 'node.children()[0].wgsl()'

  binary_expr:
    index_key_source:
      key: |-
        let fn_name = switch node.binary_operator.slice() {
          "+" => "__add__",
          "-" => "__sub__",
          "*" => "__mul__",
          "/" => "__div__",
          "%" => "__mod__",
          "<" => "__lt__",
          ">" => "__gt__",
          "<=" => "__le__",
          ">=" => "__ge__",
          "==" => "__eq__",
          "!=" => "__ne__",
          "&&" => "__and__",
          "||" => "__or__",
        };
        ```${fn_name}(${node.children()[0].type()}, ${node.children()[2].type()})`` function`
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.children()[0].wgsl()}, ${node.children()[2].wgsl()})`'
    type_resolution:
      source_children: [ fn_return_type ]


  f32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: '.', end: '.' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`f32` literal'
    validation:
      - assertion: 'parse_f32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `f32` literal"'
    type_resolution:
      name: f32
    transpilation: '`f32(${node.slice().replaced("_", "")})`'

  u32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: 'u', end: 'u' }
        min_length: 1
        max_length: 1
    display_name: '`u32` literal'
    validation:
      - assertion: 'parse_u32(node.slice().replaced("_", "").replaced("u", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `u32` literal"'
    type_resolution:
      name: u32
    transpilation: '`u32(${node.slice().replaced("_", "")})`'

  i32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`i32` literal'
    validation:
      - assertion: 'parse_i32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `i32` literal"'
    type_resolution:
      name: i32
    transpilation: '`i32(${node.slice().replaced("_", "")})`'

  true_expr:
    string: 'true'
    type_resolution:
      name: bool
    transpilation: '"u32(true)"'

  false_expr:
    string: 'false'
    type_resolution:
      name: bool
    transpilation: '"u32(false)"'
