max_u32: &max_u32 4294967295

missing_source_check: &missing_source_check
  assertion: 'node.has_source()'
  error:
    node: 'node'
    title: '"undefined item"'
    label: '`${node.source_key()} is undefined`'

binary_expr_transpilation: &binary_expr_transpilation |-
  fn operands(operator, fn_arg) {
    let expr = fn_arg.expr.children()[0];
    let binary_right_arg = expr.children().get(2);
    if binary_right_arg != () && binary_right_arg.kind() == "binary_right_arg" && expr.children()[1].slice() == operator {
      [expr.fn_arg] + operands(operator, binary_right_arg.fn_arg)
    } else {
      return [fn_arg]
    }
  }
  fn transpile(operator_fn_name, operands) {
    if operands.len() == 2 {
      `${operator_fn_name}(${operands[0].wgsl()}, ${operands[1].wgsl()})`
    } else {
      let last_operand = operands.pop();
      `${operator_fn_name}(${transpile(operator_fn_name, operands)}, ${last_operand.wgsl()})`
    }
  }
  let operator = node.children()[1].slice();
  let operator_fn_name = switch operator {
    "-" => "__sub__",
    "*" => "__mul__",
  };
  transpile(operator_fn_name, [node.fn_arg] + operands(operator, node.binary_right_arg.fn_arg))


kinds:
  typed_expr:
    sequence: [ expr ]
    sequence_error_after: expr
    validation:
      - assertion: 'node.type() != "<no return>"'
        error:
          node: 'node'
          title: '"invalid expression type"'
          label: '"this function does not return a value"'
    transpilation: 'node.expr.wgsl()'

  expr:
    choice:
      - binary_sub_expr
      - binary_mul_expr
      - associated_fn_call_expr
      - fn_call_expr
      - true_expr
      - false_expr
      - var_ident_expr
      - f32_expr
      - u32_expr
      - i32_expr
    transpilation: 'node.children()[0].wgsl()'

  var_ident_expr:
    sequence: [ ident ]
    sequence_error_after: ident
    index_key_source:
      key:
        - string: '`'
        - slice: true
        - string: '` variable'
      criteria:
        - kind: local_var_def_stmt
          can_be_after: false
        - kind: fn_param
          can_be_after: false
          allowed_siblings:
            - parent_index: 1 # `fn_item` node
              child_offset: 4 # `fn_param_group` child node
        - kind: buffer_item
          can_be_after: true
    validation:
      - *missing_source_check
    type_resolution:
      source_children: [ typed_expr, param_type ]
    transpilation: '`_${node.source().id()}`'

  fn_call_expr:
    sequence: [ ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: open_parenthesis
    index_key_source:
      key:
        - string: '`'
        - slice_child: ident
        - string: '('
        - type_nested_child: fn_arg
          separator: ', '
        - string: ')` function'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.fn_arg_group.wgsl()})`'
    type_resolution:
      source_children: [ fn_return_type ]

  associated_fn_call_expr:
    sequence: [ fn_arg, dot, ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: dot
    index_key_source:
      # TODO: convert to Rhai?
      key:
        - string: '`'
        - slice_child: ident
        - string: '('
        - type_nested_child: fn_arg
          separator: ', '
        - string: ')` function'
      criteria:
        - kind: fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: '`_${node.source().id()}(${node.fn_arg.wgsl()}, ${node.fn_arg_group.wgsl()})`'
    type_resolution:
      source_children: [ fn_return_type ]

  fn_arg_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ fn_arg, fn_other_args, fn_args_final_comma ]
    sequence_error_after: fn_arg
    transpilation: 'node.fn_arg.wgsl() + node.fn_other_args.wgsl()'

  fn_arg:
    sequence: [ expr ]
    sequence_error_after: expr
    transpilation: 'node.expr.wgsl()'

  fn_other_args:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, fn_arg ]
    sequence_error_after: fn_arg
    transpilation: '", " + node.fn_arg.wgsl()'

  fn_args_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  binary_sub_expr:
    sequence: [ fn_arg, hyphen, binary_right_arg ]
    sequence_error_after: hyphen
    transpilation: *binary_expr_transpilation

  binary_mul_expr:
    sequence: [ fn_arg, star, binary_right_arg ]
    sequence_error_after: star
    transpilation: *binary_expr_transpilation

  binary_right_arg:
    sequence: [ fn_arg ]
    sequence_error_after: fn_arg

  f32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: '.', end: '.' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`f32` literal'
    validation:
      - assertion: 'parse_f32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `f32` literal"'
    type_resolution:
      name: f32
    transpilation: '`f32(${node.slice().replaced("_", "")})`'

  u32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: 'u', end: 'u' }
        min_length: 1
        max_length: 1
    display_name: '`u32` literal'
    validation:
      - assertion: 'parse_u32(node.slice().replaced("_", "").replaced("u", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `u32` literal"'
    type_resolution:
      name: u32
    transpilation: '`u32(${node.slice().replaced("_", "")})`'

  i32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`i32` literal'
    validation:
      - assertion: 'parse_i32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `i32` literal"'
    type_resolution:
      name: i32
    transpilation: '`i32(${node.slice().replaced("_", "")})`'

  true_expr:
    string: 'true'
    type_resolution:
      name: bool
    transpilation: '"u32(true)"'

  false_expr:
    string: 'false'
    type_resolution:
      name: bool
    transpilation: '"u32(false)"'
