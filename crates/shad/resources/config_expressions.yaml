max_u32: &max_u32 4294967295

missing_source_check: &missing_source_check
  assertion: |-
    node.source_key(); // to ensure the source key can be computed 
    node.has_source()
  error:
    node: 'node'
    title: '"undefined item"'
    label: '`${node.source_key()} is undefined`'

unary_transpilation: &unary_transpilation |-
  let source = node.source();
  if source.kind() == "native_fn_item" {
    let transpilation = source.string.slice().sub_string(1, source.string.slice().len() - 2);
    let param = source.nested_children("fn_param")[0];
    let arg = node.children()[1];
    transpilation.replace(param.ident.slice(), arg.wgsl());
    transpilation
  } else {
    `_${source.id()}(${node.children()[1].wgsl()})`
  }

kinds:
  typed_expr:
    sequence: [ expr ]
    sequence_error_after: expr
    validation:
      - assertion: 'node.type() != "<no return>"'
        error:
          node: 'node'
          title: '"invalid expression type"'
          label: '"this function does not return a value"'
    transpilation: 'node.children()[0].wgsl()'

  expr:
    sequence: [ binary_operand, binary_right ]
    sequence_error_after: binary_operand
    binary_transformation:
      new_kind: binary_expr
      operand: [ binary_operand, transformed_binary_operand ]
      operator: [ binary_operator ]
      operator_priority:
        - [ '||' ]
        - [ '&&' ]
        - [ '<', '>', '<=', '>=', '==', '!=' ]
        - [ '+', '-' ]
        - [ '*', '/',  '%' ]
    transpilation: 'node.children()[0].wgsl()'

  binary_right:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ binary_operator, binary_operand ]
    sequence_error_after: binary_operator

  binary_expr:
    index_key_source:
      key: |-
        let fn_name = switch node.binary_operator.slice() {
          "+" => "__add__",
          "-" => "__sub__",
          "*" => "__mul__",
          "/" => "__div__",
          "%" => "__mod__",
          "<" => "__lt__",
          ">" => "__gt__",
          "<=" => "__le__",
          ">=" => "__ge__",
          "==" => "__eq__",
          "!=" => "__ne__",
          "&&" => "__and__",
          "||" => "__or__",
        };
        ```${fn_name}(${node.children()[0].type()}, ${node.children()[2].type()})`` function`
      criteria:
        - kind: fn_item
          can_be_after: true
        - kind: native_fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: |-
      let source = node.source();
      if source.kind() == "native_fn_item" {
        let transpilation = source.string.slice().sub_string(1, source.string.slice().len() - 2);
        let params = source.nested_children("fn_param");
        let args = [node.children()[0], node.children()[2]];
        for i in 0..params.len() {
          transpilation.replace(params[i].ident.slice(), args[i].wgsl());
        }
        transpilation
      } else {
        `_${source.id()}(${node.children()[0].wgsl()}, ${node.children()[2].wgsl()})`
      }

    type_resolution:
      source_children: [ fn_return_type ]

  binary_operand:
    sequence: [ simple_expr, associated_fn_call_suffix ]
    sequence_error_after: simple_expr
    repeated_suffix_transformation:
      new_kind: transformed_binary_operand
      new_child_kind: associated_fn_call
      prefix: simple_expr
      suffix: associated_fn_call_suffix
    transpilation: 'node.simple_expr.wgsl()'

  transformed_binary_operand:
    transpilation: 'node.associated_fn_call.wgsl()'

  associated_fn_call_suffix:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ dot, ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: dot

  associated_fn_call:
    index_key_source:
      key: '```${node.associated_fn_call_suffix.ident.slice()}(${([node.children()[0]] + node.associated_fn_call_suffix.nested_children("expr")).map(|| this.type()).join(", ")})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
        - kind: native_fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: |-
      let source = node.source();
      if source.kind() == "native_fn_item" {
        let transpilation = source.string.slice().sub_string(1, source.string.slice().len() - 2);
        let params = source.nested_children("fn_param");
        let args = ([node.children()[0]] + node.associated_fn_call_suffix.nested_children("expr"));
        for i in 0..params.len() {
          transpilation.replace(params[i].ident.slice(), args[i].wgsl());
        }
        transpilation
      } else {
        `_${source.id()}(${node.children()[0].wgsl()}, ${node.associated_fn_call_suffix.fn_arg_group.wgsl()})`
      }
    type_resolution:
      source_children: [ fn_return_type ]

  simple_expr:
    choice:
      - fn_call_expr
      - parenthesis_expr
      - true_expr
      - false_expr
      - var_ident_expr
      - f32_expr
      - u32_expr
      - i32_expr
      - neg_unary_expr
      - not_unary_expr
    transpilation: 'node.children()[0].wgsl()'

  var_ident_expr:
    sequence: [ ident ]
    sequence_error_after: ident
    index_key_source:
      key: '```${node.slice()}`` variable`'
      criteria:
        - kind: local_var_def_stmt
          can_be_after: false
        - kind: fn_param
          can_be_after: false
          allowed_siblings:
            - parent_index: 1 # `fn_item`/`native_fn_item` node
              child_offsets: [ 4, 5 ] # `fn_param_group` child node
        - kind: buffer_item
          can_be_after: true
    validation:
      - *missing_source_check
    type_resolution:
      source_children: [ typed_expr, param_type ]
    transpilation: '`_${node.source().id()}`'

  fn_call_expr:
    sequence: [ ident, open_parenthesis, fn_arg_group, close_parenthesis ]
    sequence_error_after: open_parenthesis
    index_key_source:
      key: '```${node.ident.slice()}(${node.nested_children("expr").map(|| this.type()).join(", ")})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
        - kind: native_fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: |-
      let source = node.source();
      if source.kind() == "native_fn_item" {
        let transpilation = source.string.slice().sub_string(1, source.string.slice().len() - 2);
        let params = source.nested_children("fn_param");
        let args = node.nested_children("expr");
        for i in 0..params.len() {
          transpilation.replace(params[i].ident.slice(), args[i].wgsl());
        }
        transpilation
      } else {
        `_${source.id()}(${node.fn_arg_group.wgsl()})`
      }
    type_resolution:
      source_children: [ fn_return_type ]

  fn_arg_group:
    min_repeat: 0
    max_repeat: 1
    sequence: [ expr, fn_other_args, fn_args_final_comma ]
    sequence_error_after: expr
    transpilation: 'node.children()[0].wgsl() + node.fn_other_args.wgsl()'

  fn_other_args:
    min_repeat: 0
    max_repeat: *max_u32
    sequence: [ comma, expr ]
    sequence_error_after: expr
    transpilation: '", " + node.children()[1].wgsl()'

  fn_args_final_comma:
    min_repeat: 0
    max_repeat: 1
    sequence: [ comma ]
    sequence_error_after: comma

  parenthesis_expr:
    sequence: [ open_parenthesis, expr, close_parenthesis ]
    sequence_error_after: open_parenthesis
    transpilation: '`(${node.children()[1].wgsl()})`'

  neg_unary_expr:
    sequence: [ hyphen, binary_operand ]
    sequence_error_after: hyphen
    index_key_source:
      key: '```__neg__(${node.children()[1].type()})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
        - kind: native_fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: *unary_transpilation

  not_unary_expr:
    sequence: [ excl_mark, binary_operand ]
    sequence_error_after: excl_mark
    index_key_source:
      key: '```__not__(${node.children()[1].type()})`` function`'
      criteria:
        - kind: fn_item
          can_be_after: true
        - kind: native_fn_item
          can_be_after: true
    validation:
      - *missing_source_check
    transpilation: *unary_transpilation

  binary_operator:
    choice:
      - plus
      - hyphen
      - star
      - slash
      - percent
      - compare_le
      - compare_ge
      - compare_eq
      - compare_ne
      - open_angle_bracket
      - close_angle_bracket
      - and
      - or
    transpilation: 'node.children()[0].wgsl()'

  f32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: '.', end: '.' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`f32` literal'
    validation:
      - assertion: 'parse_f32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `f32` literal"'
    type_resolution:
      name: f32
    transpilation: '`f32(${node.slice().replaced("_", "")})`'

  u32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
      - char_ranges:
          - { start: 'u', end: 'u' }
        min_length: 1
        max_length: 1
    display_name: '`u32` literal'
    validation:
      - assertion: 'parse_u32(node.slice().replaced("_", "").replaced("u", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `u32` literal"'
    type_resolution:
      name: u32
    transpilation: '`u32(${node.slice().replaced("_", "")})`'

  i32_expr:
    pattern_parts:
      - char_ranges:
          - { start: '-', end: '-' }
        min_length: 0
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
        min_length: 1
        max_length: 1
      - char_ranges:
          - { start: '0', end: '9' }
          - { start: '_', end: '_' }
        min_length: 0
        max_length: *max_u32
    display_name: '`i32` literal'
    validation:
      - assertion: 'parse_i32(node.slice().replaced("_", "")).is_some()'
        error:
          node: 'node'
          title: '"out of bound `i32` literal"'
    type_resolution:
      name: i32
    transpilation: '`i32(${node.slice().replaced("_", "")})`'

  true_expr:
    string: 'true'
    type_resolution:
      name: bool
    transpilation: '"u32(true)"'

  false_expr:
    string: 'false'
    type_resolution:
      name: bool
    transpilation: '"u32(false)"'
