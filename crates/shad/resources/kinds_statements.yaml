max_u32: &max_u32 4294967295
no_return_type_name: &no_return_type_name '<no return>'

kinds:
  stmts:
    min_repeat: 0
    max_repeat: *max_u32
    choice:
      - local_var_def_stmt
      - assignment_stmt
      - fn_call_stmt
      - return_stmt

  local_var_def_stmt:
    sequence: [ var_kw, ident, eq, typed_expr, semicolon ]
    sequence_error_after: var_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    transpilation: '`var _${node.id()} = ${node.child("typed_expr").req().transpile()};`'

  assignment_stmt:
    sequence: [ var_ident_expr, eq, typed_expr, semicolon ]
    sequence_error_after: eq
    validation:
      - assertion: |-
          let expr_type = node.child("typed_expr").req().type().req();
          let expected_type = node.child("var_ident_expr").req().type().req();
          expr_type == "<no return>" || expected_type == "<no return>" || expr_type == expected_type
        error:
          node: 'node.child("typed_expr").req()'
          title: '"invalid expression type"'
          label: '`expression type is ``${node.child("typed_expr").req().type().req()}```'
          info:
            - node: 'node.child("var_ident_expr").req()'
              title: '`expected type is ``${node.child("var_ident_expr").req().type().req()}```'
    transpilation: '`${node.child("var_ident_expr").req().transpile()} = ${node.child("typed_expr").req().transpile()};`'

  fn_call_stmt:
    sequence: [ fn_call_expr, semicolon ]
    sequence_error_after: fn_call_expr
    transpilation: '`${node.child("fn_call_expr").req().transpile()};`'

  return_stmt:
    sequence: [ return_kw, typed_expr, semicolon ]
    sequence_error_after: return_kw
    transpilation: '`return ${node.child("typed_expr").req().transpile()};`'
