max_u32: &max_u32 4294967295

kinds:
  stmts:
    min_repeat: 0
    max_repeat: *max_u32
    choice:
      - local_var_def_stmt
      - assignment_stmt
      - fn_call_stmt
      - associated_fn_call_stmt
      - return_stmt
    transpilation: 'node.children()[0].wgsl()'

  local_var_def_stmt:
    sequence: [ var_kw, ident, eq, typed_expr, semicolon ]
    sequence_error_after: var_kw
    index_key:
      - string: '`'
      - child: ident
      - string: '` variable'
    transpilation: '`var _${node.id()} = ${node.typed_expr.wgsl()};`'

  assignment_stmt:
    sequence: [ var_ident_expr, eq, typed_expr, semicolon ]
    sequence_error_after: eq
    validation:
      - assertion: |-
          let expr_type = node.typed_expr.type();
          let expected_type = node.var_ident_expr.type();
          expr_type == "<no return>" || expected_type == "<no return>" || expr_type == expected_type
        error:
          node: 'node.typed_expr'
          title: '"invalid expression type"'
          label: '`expression type is ``${node.typed_expr.type()}```'
          info:
            - node: 'node.var_ident_expr'
              title: '`expected type is ``${node.var_ident_expr.type()}```'
    transpilation: '`${node.var_ident_expr.wgsl()} = ${node.typed_expr.wgsl()};`'

  fn_call_stmt:
    sequence: [ fn_call_expr, semicolon ]
    sequence_error_after: fn_call_expr
    transpilation: '`${node.fn_call_expr.wgsl()};`'

  associated_fn_call_stmt:
    sequence: [ associated_fn_call_expr, semicolon ]
    sequence_error_after: associated_fn_call_expr
    transpilation: '`${node.associated_fn_call_expr.wgsl()};`'

  return_stmt:
    sequence: [ return_kw, typed_expr, semicolon ]
    sequence_error_after: return_kw
    transpilation: '`return ${node.typed_expr.wgsl()};`'
